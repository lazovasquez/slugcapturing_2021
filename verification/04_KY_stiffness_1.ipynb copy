{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "ename": "ModuleNotFoundError",
     "evalue": "No module named 'dolfin'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-1-9f27d1a47523>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     12\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0mscipy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlinalg\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0meig\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     13\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0mscipy\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0msparse\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 14\u001b[0;31m \u001b[0;32mfrom\u001b[0m \u001b[0mdolfin\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     15\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0mnumpy\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mlinalg\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mLA\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     16\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0mscipy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msparse\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlinalg\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0meigs\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'dolfin'"
     ]
    }
   ],
   "source": [
    "# Kreiss-Ystrom\n",
    "# 1/2 MATRIX PLOT\n",
    "\n",
    "#http://hplgit.github.io/INF5620/doc/pub/fenics_tutorial1.1/tu2.html\n",
    "import matplotlib.pyplot as plt\n",
    "import scipy.sparse as sparse\n",
    "import numpy as np\n",
    "import matplotlib\n",
    "\n",
    "from matplotlib.ticker import (MultipleLocator, FormatStrFormatter, AutoMinorLocator)\n",
    "from scipy.sparse import csr_matrix\n",
    "from scipy.linalg import eig\n",
    "from scipy import sparse\n",
    "from dolfin import *\n",
    "from numpy import linalg as LA\n",
    "from scipy.sparse.linalg import eigs\n",
    "from IPython.display import clear_output\n",
    "\n",
    "# Test for PETSc and SLEPc\n",
    "if not has_linear_algebra_backend(\"PETSc\"):\n",
    "    print(\"DOLFIN has not been configured with PETSc. Exiting.\")\n",
    "    exit()\n",
    "\n",
    "if not has_slepc():\n",
    "    print(\"DOLFIN has not been configured with SLEPc. Exiting.\")\n",
    "    exit()\n",
    "\n",
    "# Form compiler options\n",
    "parameters['form_compiler']['representation'] = 'uflacs'\n",
    "parameters [\"form_compiler\"][\"optimize\"]          = True\n",
    "parameters [\"form_compiler\"][\"cpp_optimize\"]      = True\n",
    "#parameters[\"form_compiler\"][\"representation\"] = \"quadrature\"\n",
    "parameters [\"form_compiler\"][\"quadrature_degree\"] = 2 #(4 for elasticity) (8 for multiphase flow)\n",
    "# http://www.karlin.mff.cuni.cz/~hron/fenics-tutorial/multiphase/doc.html MULTIPHASE FLOW\"\"\"\"\"\"\n",
    "\n",
    "parameters [\"form_compiler\"][\"cpp_optimize\"]      = True\n",
    "ffc_options = {\"optimize\": True, \\\n",
    "               \"eliminate_zeros\": True, \\\n",
    "               \"precompute_basis_const\": True, \\\n",
    "               \"precompute_ip_const\": True}\n",
    "\n",
    "# Allow approximating values for points that may be generated outside\n",
    "# of domain (because of numerical inaccuracies)\n",
    "parameters[\"allow_extrapolation\"] = True\n",
    "parameters[\"refinement_algorithm\"] = \"plaza_with_parent_facets\"\n",
    "\n",
    "# Degree of FEM\n",
    "p      = 2  \n",
    "\n",
    "# Define constants\n",
    "u1bc1   = Expression (\"exp(-2*pow(x[0],2))\", degree = p - 1)#0.5 # alpha0\n",
    "u2bc1   = Expression (\"exp(-4*pow(x[0],2))\", degree = p) # u0 = 1.0\n",
    "C       = 1 # 1 non hyperbolic, -1 hyperbolic\n",
    "nu      = 0.05 # 0 without viscosity (ill posed)\n",
    "epsilon = 0.05\n",
    "\n",
    "# Define space discretization properties\n",
    "xmin   = 0\n",
    "xmax   = 2*pi\n",
    "nx     = 512 #o. of elements 100 to 800\n",
    "\n",
    "mesh   = IntervalMesh (nx, xmin, xmax)\n",
    "#deltax = CellDiameter (mesh)\n",
    "#hmin   = mesh.hmin ()\n",
    "#deltax = 0.02 # 1 to 0.02m\n",
    "\n",
    "# Save mesh\n",
    "File (\"kreiss-ystrom_higherorder_prec_solvers/mesh.xml\") << mesh\n",
    "\n",
    "# Define time discretization properties\n",
    "T         = 1.0            # final time\n",
    "#Co        = 0.5\n",
    "dt        = 0.0002 #Co*deltax/u2bc1 # 0.004*deltax KY 2\n",
    "num_steps = round(T / dt)\n",
    "\n",
    "# Define funcion spaces\n",
    "V1      = FiniteElement ('Lagrange', mesh.ufl_cell(), degree = p)\n",
    "V2      = FiniteElement ('Lagrange', mesh.ufl_cell(), degree = p - 1)\n",
    "element = MixedElement ([V1, V2])\n",
    "V       = FunctionSpace (mesh, element)\n",
    "\n",
    "# Define test and trial functions\n",
    "v1, v2     = TestFunctions (V)\n",
    "\n",
    "u          = Function (V, name = \"Variables at current step\")\n",
    "u1, u2     = split (u)\n",
    "\n",
    "du         = TrialFunction (V)\n",
    "\n",
    "# Define initial condition\n",
    "class InitialConditions (UserExpression):\n",
    "#     def __init__ (self, **kwargs):\n",
    "#         super (InitialConditions, self).__init__(**kwargs)\n",
    "    def eval (self, values, x):\n",
    "        values[0] = cos(x[0]) #u1bc1\n",
    "        values[1] = sin(x[0] - pi/3) # sin(x-pi/3)\n",
    "    def value_shape (self):\n",
    "        return (2,)\n",
    "\n",
    "u_ic       = InitialConditions(degree = p)\n",
    "u_n        = interpolate (u_ic, V) \n",
    "u_n1, u_n2 = split (u_n)\n",
    "\n",
    "# Plot initial conditions\n",
    "plt.figure (1, figsize = (8, 4))\n",
    "plt.grid (True, which = \"both\")\n",
    "plot (u_n1, wireframe = True, title = \"Initial liquid holdup\")\n",
    "\n",
    "plt.figure (2, figsize = (8, 4))\n",
    "plt.grid (True, which = \"both\")\n",
    "plot (u_n2, wireframe = True, title = \"Initial liquid velocity\")\n",
    "\n",
    "plt.show ()\n",
    "\n",
    "# Define boundary condition\n",
    "u1_bc1 = Expression (\"u1bc1\", degree = p, u1bc1 = u1bc1)\n",
    "#u1_bc2 = Expression (\"u1bc2\", degree = p, u1bc2 = u1bc2)\n",
    "u2_bc1 = Expression (\"u2bc1\", degree = p, u2bc1 = u2bc1)\n",
    "#u2_bc2 = Expression (\"u2bc2\", degree = p, u2bc2 = u2bc2)\n",
    "\n",
    "# Sub domain for Dirichlet boundary condition\n",
    "def right (x, on_boundary): \n",
    "    return x[0] > (2*pi - DOLFIN_EPS)\n",
    "def left (x, on_boundary): \n",
    "    return x[0] < DOLFIN_EPS\n",
    "\n",
    "bc1 = DirichletBC(V.sub (0), u1_bc1, left)\n",
    "#bc2 = DirichletBC(V.sub (1), u1_bc2, right)\n",
    "bc3 = DirichletBC(V.sub (1), u2_bc1, left)\n",
    "#bc4 = DirichletBC(V.sub (1), u2_bc2, right)\n",
    "bcs = [bc1, bc3]\n",
    "\n",
    "# Define expressions used in weak form\n",
    "nu      = Expression (\"nu\", degree = p, nu = nu)\n",
    "epsilon = Expression (\"epsilon\", degree = p, epsilon = epsilon)\n",
    "C       = Expression (\"C\", degree = p, C = C)\n",
    "k = Expression(\"dt\", degree = p, dt = dt)\n",
    "\n",
    "def func1(u1,u2):\n",
    "    term1 = 1 + (u1/2)\n",
    "    return term1\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      ">>> diffusion coeff =  5e-05\n"
     ]
    },
    {
     "ename": "NameError",
     "evalue": "name 'u2' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-2-445e717c9fcb>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      4\u001b[0m     \u001b[0mF\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m-\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mu2\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mv1\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mDx\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mu1\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mdx\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfunc1\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mu1\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mu2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mv1\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mDx\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mu2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mdx\u001b[0m \u001b[0;34m-\u001b[0m\u001b[0;31m \u001b[0m\u001b[0;31m\\\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m     \u001b[0;36m2\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mu1\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mv1\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mdx\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0minner\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcoeff\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mgrad\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mu1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mgrad\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mv1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mdx\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mu2\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mv2\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mDx\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mu2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mdx\u001b[0m \u001b[0;34m+\u001b[0m\u001b[0;31m \u001b[0m\u001b[0;31m\\\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 6\u001b[0;31m     \u001b[0;34m(\u001b[0m\u001b[0mC\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mv2\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mDx\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mu1\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mdx\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0minner\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcoeff\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mgrad\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mu2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mgrad\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mv2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mdx\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      7\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      8\u001b[0m     \u001b[0;31m# Auxiliary\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'u2' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "for coeff in 0.00005, 0.05, 0.5, 1.0, 2, 5:\n",
    "    print('>>> diffusion coeff = ',coeff)\n",
    "    # Define weak form with higher order terms\n",
    "    F = -(u2*v1*Dx(u1,0))*dx - ((func1 (u1, u2)))*(v1*Dx(u2,0))*dx - \\\n",
    "    2*u1*v1*dx + (inner(coeff*grad(u1), grad(v1)))*dx - (u2*v2*Dx(u2,0))*dx + \\\n",
    "    (C*v2*Dx(u1,0))*dx + (inner(coeff*grad(u2), grad(v2)))*dx\n",
    "\n",
    "    # Auxiliary\n",
    "    L = Constant(0)*v1*dx + Constant(0)*v2*dx\n",
    "\n",
    "    # Define Jacobian\n",
    "    dF = derivative (F, u, du)\n",
    "\n",
    "    # Assemble stiffness form    \n",
    "    A = PETScMatrix()\n",
    "    b = PETScVector()\n",
    "\n",
    "    assemble_system(dF, L, bcs, A_tensor = A, b_tensor = b)\n",
    "\n",
    "    A_mat = as_backend_type(A).mat()\n",
    "\n",
    "    # Transform to numpy array\n",
    "    A_sparray = csr_matrix(A_mat.getValuesCSR()[::-1], shape = A_mat.size)\n",
    "\n",
    "    # Print array\n",
    "    # print(\"A_sparray             =\", A_sparray)\n",
    "\n",
    "    # Plot array\n",
    "    plt.figure (3, figsize = (12, 8))\n",
    "    plt.spy(A_sparray)\n",
    "    plt.grid (True, which = \"both\")\n",
    "    # plt.rcParams ['figure.figsize'] = [12, 8]\n",
    "\n",
    "    plt.show\n",
    "\n",
    "    # eigenvalue problem Kreiss Ystrom\n",
    "    # 2/2\n",
    "\n",
    "    Acomplex_sparse = A_sparray.dot (1j)\n",
    "\n",
    "    Aeval           = A_sparray.toarray()\n",
    "    Acomplex        = Aeval.dot (1j)\n",
    "\n",
    "    condnumber = LA.cond(Aeval)\n",
    "    print(\"Condition number :\", condnumber)\n",
    "\n",
    "    #The array v of eigenvectors may not be of maximum rank, \n",
    "    #that is, some of the columns may be linearly dependent, \n",
    "    #although round-off error may obscure that fact. \n",
    "    #If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent.\n",
    "    # TUTORIALS\n",
    "    # https://fenicsproject.org/qa/13796/formulating-an-eigenvalue-problem/\n",
    "    # https://fenicsproject.org/qa/8680/solving-generalized-eigenvalues-finite-element-stiff-matrix/\n",
    "\n",
    "    vals, vecs = eig ( - Acomplex, overwrite_a = True)\n",
    "#     vals, vecs = eig ( Acomplex, overwrite_a = True)\n",
    "    \n",
    "    # vals, vecs = eigs ( - Acomplex_sparse) #tol = 1e-10\n",
    "\n",
    "    # Eigenvalues\n",
    "    imagvals = vals.imag\n",
    "    realvals = vals.real\n",
    "\n",
    "#     print(\"realvals = \", vals.real)\n",
    "#     print(\"imagvals = \", vals.imag)\n",
    "\n",
    "    # Characteristics for plots\n",
    "    liststyles       = [\"--\", \"-\", \"-.\", \".\"]\n",
    "    listcolor        = [\"k\", \"g\", \"b\", \"r\", \"none\"]\n",
    "    listmarkers      = [\"s\", \"o\", \"^\", \">\", \"<\", \"p\"]\n",
    "\n",
    "    # Plot eigenspectra\n",
    "    fig, ax = plt.subplots ()\n",
    "    area = 50\n",
    "\n",
    "    ax.scatter (realvals, imagvals, s = area, marker = listmarkers [0], color = listcolor [4], edgecolors = listcolor [0], linewidths = 1.5, alpha = 0.5)\n",
    "    ax.set_xscale ('symlog', linthreshx = 1e-5)\n",
    "\n",
    "    plt.rcParams ['figure.figsize'] = [12, 8]\n",
    "    # leg1 = ax.legend (loc = 'upper right', frameon = True, fontsize = 14);\n",
    "    plt.grid (True, which = \"both\")\n",
    "    plt.xlabel ('Re $[\\omega]$ [1/s]', fontsize = 18)\n",
    "    plt.ylabel ('Im $[\\omega]$ [1/s]', fontsize = 16)\n",
    "\n",
    "    matplotlib.rc ('xtick', labelsize = 18)     \n",
    "    matplotlib.rc ('ytick', labelsize = 18)\n",
    "\n",
    "    # plt.ylim (( - 0.002 , 0.002))\n",
    "    # plt.xlim (( 1e-3, 1e1))\n",
    "    plt.show ()    \n",
    "    \n",
    "\n",
    "    # Eigenvectors\n",
    "    localmaxreal = np.where(vals.real == vals.real.max())\n",
    "    localmaximag = np.where(vals.imag == vals.imag.max())\n",
    "\n",
    "    print(\"localmaxreal =\", localmaxreal)\n",
    "    print(\"localmaximag =\", localmaximag)\n",
    "\n",
    "    eigenvector_real = vecs.real[localmaxreal[0]]\n",
    "    eigenvector_imag = vecs.imag[localmaximag[0]]\n",
    "\n",
    "    print(\"eigenvector_real =\", eigenvector_real[0])\n",
    "    print(\"eigenvector_imag =\", eigenvector_imag[0])\n",
    "\n",
    "\n",
    "    # Plot real eigenvectors\n",
    "    ureal  = Function(V)\n",
    "    ureal.vector()[:] = eigenvector_real[0] #len(vecs)-1 \n",
    "    u1real, u2real = ureal.split()\n",
    "\n",
    "    # Plot eigenfunction\n",
    "    plt.figure (3, figsize = (12, 8))\n",
    "    plot(u1real, wireframe = True, title = 'Eigenfunction')\n",
    "    plt.grid (True, which = \"both\")\n",
    "    plt.xlabel(\"L\")\n",
    "    plt.ylabel(\"rx (Eigenvector of the largest real eigenvalue)\")\n",
    "\n",
    "    # Plot eigenfunction\n",
    "    plt.figure (3, figsize = (12, 8))\n",
    "    plot(u2real, wireframe = True, title = 'Eigenfunction')\n",
    "    plt.grid (True, which = \"both\")\n",
    "    plt.xlabel(\"L\")\n",
    "    plt.ylabel(\"rx (Eigenvector of the largest real eigenvalue)\")\n",
    "\n",
    "#     # Plot imaginary eigenvectors\n",
    "#     uimag = Function(V)\n",
    "#     uimag.vector()[:] = eigenvector_imag[0] #eigenfunction)\n",
    "#     u1imag, u2imag = uimag.split()\n",
    "\n",
    "#     # Plot eigenfunction\n",
    "#     plt.figure (4, figsize = (12, 8))\n",
    "#     plot(u1imag, wireframe = True, title = 'Eigenfunction')\n",
    "#     plt.grid (True, which = \"both\")\n",
    "#     plt.xlabel(\"L\")\n",
    "#     plt.ylabel(\"cx (Eigenvector of the largest imaginary eigenvalue)\")\n",
    "\n",
    "#     plt.figure (4, figsize = (12, 8))\n",
    "#     plot(u2imag, wireframe = True, title = 'Eigenfunction')\n",
    "#     plt.grid (True, which = \"both\")\n",
    "#     plt.xlabel(\"L\")\n",
    "#     plt.ylabel(\"cx (Eigenvector of the largest imaginary eigenvalue)\")\n",
    "\n",
    "    plt.show()\n",
    "\n",
    "    # SAVE LARGEST REAL\n",
    "    File(\"eigenmodes_ky_reuniao/eigenmodesu1_real.pvd\") << u1real\n",
    "    File(\"eigenmodes_ky_reuniao/eigenmodesu2_real.pvd\") << u2real\n",
    "\n",
    "#     # SAVE LARGEST IMAGINARY\n",
    "#     File(\"eigenmodes_ky/eigenmodesu1_imag.pvd\") << u1imag\n",
    "#     File(\"eigenmodes_ky/eigenmodesu2_imag.pvd\") << u2imag"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comment on KY stability (based on Acomplex and eI(omega*t-ks)):\n",
    "#     - The higher diffusion, the larger imaginary part of eigenvalues\n",
    "#                             thge larger positive real part of eigenvalues\n",
    "#                             the smaller modes with real part\n",
    "#                             no negative imaginary part of eigenvalues"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
